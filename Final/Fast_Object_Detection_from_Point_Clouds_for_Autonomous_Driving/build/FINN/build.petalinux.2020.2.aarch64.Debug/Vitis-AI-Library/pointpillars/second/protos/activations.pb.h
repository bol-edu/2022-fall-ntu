// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: second/protos/activations.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_second_2fprotos_2factivations_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_second_2fprotos_2factivations_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3009000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3009002 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_second_2fprotos_2factivations_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_second_2fprotos_2factivations_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[9]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_second_2fprotos_2factivations_2eproto;
namespace second {
namespace protos {
class Activation;
class ActivationDefaultTypeInternal;
extern ActivationDefaultTypeInternal _Activation_default_instance_;
class ELU;
class ELUDefaultTypeInternal;
extern ELUDefaultTypeInternal _ELU_default_instance_;
class LeakyReLU;
class LeakyReLUDefaultTypeInternal;
extern LeakyReLUDefaultTypeInternal _LeakyReLU_default_instance_;
class ReLU;
class ReLUDefaultTypeInternal;
extern ReLUDefaultTypeInternal _ReLU_default_instance_;
class ReLU6;
class ReLU6DefaultTypeInternal;
extern ReLU6DefaultTypeInternal _ReLU6_default_instance_;
class SELU;
class SELUDefaultTypeInternal;
extern SELUDefaultTypeInternal _SELU_default_instance_;
class Softplus;
class SoftplusDefaultTypeInternal;
extern SoftplusDefaultTypeInternal _Softplus_default_instance_;
class Softsign;
class SoftsignDefaultTypeInternal;
extern SoftsignDefaultTypeInternal _Softsign_default_instance_;
class Swish;
class SwishDefaultTypeInternal;
extern SwishDefaultTypeInternal _Swish_default_instance_;
}  // namespace protos
}  // namespace second
PROTOBUF_NAMESPACE_OPEN
template<> ::second::protos::Activation* Arena::CreateMaybeMessage<::second::protos::Activation>(Arena*);
template<> ::second::protos::ELU* Arena::CreateMaybeMessage<::second::protos::ELU>(Arena*);
template<> ::second::protos::LeakyReLU* Arena::CreateMaybeMessage<::second::protos::LeakyReLU>(Arena*);
template<> ::second::protos::ReLU* Arena::CreateMaybeMessage<::second::protos::ReLU>(Arena*);
template<> ::second::protos::ReLU6* Arena::CreateMaybeMessage<::second::protos::ReLU6>(Arena*);
template<> ::second::protos::SELU* Arena::CreateMaybeMessage<::second::protos::SELU>(Arena*);
template<> ::second::protos::Softplus* Arena::CreateMaybeMessage<::second::protos::Softplus>(Arena*);
template<> ::second::protos::Softsign* Arena::CreateMaybeMessage<::second::protos::Softsign>(Arena*);
template<> ::second::protos::Swish* Arena::CreateMaybeMessage<::second::protos::Swish>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace second {
namespace protos {

// ===================================================================

class ReLU :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:second.protos.ReLU) */ {
 public:
  ReLU();
  virtual ~ReLU();

  ReLU(const ReLU& from);
  ReLU(ReLU&& from) noexcept
    : ReLU() {
    *this = ::std::move(from);
  }

  inline ReLU& operator=(const ReLU& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReLU& operator=(ReLU&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ReLU& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ReLU* internal_default_instance() {
    return reinterpret_cast<const ReLU*>(
               &_ReLU_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(ReLU& a, ReLU& b) {
    a.Swap(&b);
  }
  inline void Swap(ReLU* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ReLU* New() const final {
    return CreateMaybeMessage<ReLU>(nullptr);
  }

  ReLU* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ReLU>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ReLU& from);
  void MergeFrom(const ReLU& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReLU* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "second.protos.ReLU";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_second_2fprotos_2factivations_2eproto);
    return ::descriptor_table_second_2fprotos_2factivations_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:second.protos.ReLU)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_second_2fprotos_2factivations_2eproto;
};
// -------------------------------------------------------------------

class LeakyReLU :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:second.protos.LeakyReLU) */ {
 public:
  LeakyReLU();
  virtual ~LeakyReLU();

  LeakyReLU(const LeakyReLU& from);
  LeakyReLU(LeakyReLU&& from) noexcept
    : LeakyReLU() {
    *this = ::std::move(from);
  }

  inline LeakyReLU& operator=(const LeakyReLU& from) {
    CopyFrom(from);
    return *this;
  }
  inline LeakyReLU& operator=(LeakyReLU&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const LeakyReLU& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LeakyReLU* internal_default_instance() {
    return reinterpret_cast<const LeakyReLU*>(
               &_LeakyReLU_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(LeakyReLU& a, LeakyReLU& b) {
    a.Swap(&b);
  }
  inline void Swap(LeakyReLU* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline LeakyReLU* New() const final {
    return CreateMaybeMessage<LeakyReLU>(nullptr);
  }

  LeakyReLU* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<LeakyReLU>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const LeakyReLU& from);
  void MergeFrom(const LeakyReLU& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LeakyReLU* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "second.protos.LeakyReLU";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_second_2fprotos_2factivations_2eproto);
    return ::descriptor_table_second_2fprotos_2factivations_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLeaknessFieldNumber = 1,
  };
  // float leakness = 1;
  void clear_leakness();
  float leakness() const;
  void set_leakness(float value);

  // @@protoc_insertion_point(class_scope:second.protos.LeakyReLU)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  float leakness_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_second_2fprotos_2factivations_2eproto;
};
// -------------------------------------------------------------------

class Swish :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:second.protos.Swish) */ {
 public:
  Swish();
  virtual ~Swish();

  Swish(const Swish& from);
  Swish(Swish&& from) noexcept
    : Swish() {
    *this = ::std::move(from);
  }

  inline Swish& operator=(const Swish& from) {
    CopyFrom(from);
    return *this;
  }
  inline Swish& operator=(Swish&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Swish& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Swish* internal_default_instance() {
    return reinterpret_cast<const Swish*>(
               &_Swish_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Swish& a, Swish& b) {
    a.Swap(&b);
  }
  inline void Swap(Swish* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Swish* New() const final {
    return CreateMaybeMessage<Swish>(nullptr);
  }

  Swish* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Swish>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Swish& from);
  void MergeFrom(const Swish& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Swish* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "second.protos.Swish";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_second_2fprotos_2factivations_2eproto);
    return ::descriptor_table_second_2fprotos_2factivations_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:second.protos.Swish)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_second_2fprotos_2factivations_2eproto;
};
// -------------------------------------------------------------------

class ELU :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:second.protos.ELU) */ {
 public:
  ELU();
  virtual ~ELU();

  ELU(const ELU& from);
  ELU(ELU&& from) noexcept
    : ELU() {
    *this = ::std::move(from);
  }

  inline ELU& operator=(const ELU& from) {
    CopyFrom(from);
    return *this;
  }
  inline ELU& operator=(ELU&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ELU& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ELU* internal_default_instance() {
    return reinterpret_cast<const ELU*>(
               &_ELU_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(ELU& a, ELU& b) {
    a.Swap(&b);
  }
  inline void Swap(ELU* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ELU* New() const final {
    return CreateMaybeMessage<ELU>(nullptr);
  }

  ELU* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ELU>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ELU& from);
  void MergeFrom(const ELU& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ELU* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "second.protos.ELU";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_second_2fprotos_2factivations_2eproto);
    return ::descriptor_table_second_2fprotos_2factivations_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAlphaFieldNumber = 1,
  };
  // float alpha = 1;
  void clear_alpha();
  float alpha() const;
  void set_alpha(float value);

  // @@protoc_insertion_point(class_scope:second.protos.ELU)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  float alpha_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_second_2fprotos_2factivations_2eproto;
};
// -------------------------------------------------------------------

class Softplus :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:second.protos.Softplus) */ {
 public:
  Softplus();
  virtual ~Softplus();

  Softplus(const Softplus& from);
  Softplus(Softplus&& from) noexcept
    : Softplus() {
    *this = ::std::move(from);
  }

  inline Softplus& operator=(const Softplus& from) {
    CopyFrom(from);
    return *this;
  }
  inline Softplus& operator=(Softplus&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Softplus& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Softplus* internal_default_instance() {
    return reinterpret_cast<const Softplus*>(
               &_Softplus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(Softplus& a, Softplus& b) {
    a.Swap(&b);
  }
  inline void Swap(Softplus* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Softplus* New() const final {
    return CreateMaybeMessage<Softplus>(nullptr);
  }

  Softplus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Softplus>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Softplus& from);
  void MergeFrom(const Softplus& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Softplus* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "second.protos.Softplus";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_second_2fprotos_2factivations_2eproto);
    return ::descriptor_table_second_2fprotos_2factivations_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBetaFieldNumber = 1,
    kThresholdFieldNumber = 2,
  };
  // float beta = 1;
  void clear_beta();
  float beta() const;
  void set_beta(float value);

  // float threshold = 2;
  void clear_threshold();
  float threshold() const;
  void set_threshold(float value);

  // @@protoc_insertion_point(class_scope:second.protos.Softplus)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  float beta_;
  float threshold_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_second_2fprotos_2factivations_2eproto;
};
// -------------------------------------------------------------------

class Softsign :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:second.protos.Softsign) */ {
 public:
  Softsign();
  virtual ~Softsign();

  Softsign(const Softsign& from);
  Softsign(Softsign&& from) noexcept
    : Softsign() {
    *this = ::std::move(from);
  }

  inline Softsign& operator=(const Softsign& from) {
    CopyFrom(from);
    return *this;
  }
  inline Softsign& operator=(Softsign&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Softsign& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Softsign* internal_default_instance() {
    return reinterpret_cast<const Softsign*>(
               &_Softsign_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(Softsign& a, Softsign& b) {
    a.Swap(&b);
  }
  inline void Swap(Softsign* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Softsign* New() const final {
    return CreateMaybeMessage<Softsign>(nullptr);
  }

  Softsign* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Softsign>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Softsign& from);
  void MergeFrom(const Softsign& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Softsign* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "second.protos.Softsign";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_second_2fprotos_2factivations_2eproto);
    return ::descriptor_table_second_2fprotos_2factivations_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:second.protos.Softsign)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_second_2fprotos_2factivations_2eproto;
};
// -------------------------------------------------------------------

class ReLU6 :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:second.protos.ReLU6) */ {
 public:
  ReLU6();
  virtual ~ReLU6();

  ReLU6(const ReLU6& from);
  ReLU6(ReLU6&& from) noexcept
    : ReLU6() {
    *this = ::std::move(from);
  }

  inline ReLU6& operator=(const ReLU6& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReLU6& operator=(ReLU6&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ReLU6& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ReLU6* internal_default_instance() {
    return reinterpret_cast<const ReLU6*>(
               &_ReLU6_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(ReLU6& a, ReLU6& b) {
    a.Swap(&b);
  }
  inline void Swap(ReLU6* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ReLU6* New() const final {
    return CreateMaybeMessage<ReLU6>(nullptr);
  }

  ReLU6* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ReLU6>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ReLU6& from);
  void MergeFrom(const ReLU6& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReLU6* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "second.protos.ReLU6";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_second_2fprotos_2factivations_2eproto);
    return ::descriptor_table_second_2fprotos_2factivations_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:second.protos.ReLU6)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_second_2fprotos_2factivations_2eproto;
};
// -------------------------------------------------------------------

class SELU :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:second.protos.SELU) */ {
 public:
  SELU();
  virtual ~SELU();

  SELU(const SELU& from);
  SELU(SELU&& from) noexcept
    : SELU() {
    *this = ::std::move(from);
  }

  inline SELU& operator=(const SELU& from) {
    CopyFrom(from);
    return *this;
  }
  inline SELU& operator=(SELU&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SELU& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SELU* internal_default_instance() {
    return reinterpret_cast<const SELU*>(
               &_SELU_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(SELU& a, SELU& b) {
    a.Swap(&b);
  }
  inline void Swap(SELU* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SELU* New() const final {
    return CreateMaybeMessage<SELU>(nullptr);
  }

  SELU* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SELU>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SELU& from);
  void MergeFrom(const SELU& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SELU* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "second.protos.SELU";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_second_2fprotos_2factivations_2eproto);
    return ::descriptor_table_second_2fprotos_2factivations_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:second.protos.SELU)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_second_2fprotos_2factivations_2eproto;
};
// -------------------------------------------------------------------

class Activation :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:second.protos.Activation) */ {
 public:
  Activation();
  virtual ~Activation();

  Activation(const Activation& from);
  Activation(Activation&& from) noexcept
    : Activation() {
    *this = ::std::move(from);
  }

  inline Activation& operator=(const Activation& from) {
    CopyFrom(from);
    return *this;
  }
  inline Activation& operator=(Activation&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Activation& default_instance();

  enum ActivationCase {
    kRelu = 1,
    kLeakyRelu = 2,
    kSwish = 3,
    kElu = 4,
    kSoftplus = 5,
    kSoftsign = 6,
    kRelu6 = 7,
    kSelu = 8,
    ACTIVATION_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Activation* internal_default_instance() {
    return reinterpret_cast<const Activation*>(
               &_Activation_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(Activation& a, Activation& b) {
    a.Swap(&b);
  }
  inline void Swap(Activation* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Activation* New() const final {
    return CreateMaybeMessage<Activation>(nullptr);
  }

  Activation* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Activation>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Activation& from);
  void MergeFrom(const Activation& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Activation* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "second.protos.Activation";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_second_2fprotos_2factivations_2eproto);
    return ::descriptor_table_second_2fprotos_2factivations_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kReluFieldNumber = 1,
    kLeakyReluFieldNumber = 2,
    kSwishFieldNumber = 3,
    kEluFieldNumber = 4,
    kSoftplusFieldNumber = 5,
    kSoftsignFieldNumber = 6,
    kRelu6FieldNumber = 7,
    kSeluFieldNumber = 8,
  };
  // .second.protos.ReLU relu = 1;
  bool has_relu() const;
  void clear_relu();
  const ::second::protos::ReLU& relu() const;
  ::second::protos::ReLU* release_relu();
  ::second::protos::ReLU* mutable_relu();
  void set_allocated_relu(::second::protos::ReLU* relu);

  // .second.protos.LeakyReLU leaky_relu = 2;
  bool has_leaky_relu() const;
  void clear_leaky_relu();
  const ::second::protos::LeakyReLU& leaky_relu() const;
  ::second::protos::LeakyReLU* release_leaky_relu();
  ::second::protos::LeakyReLU* mutable_leaky_relu();
  void set_allocated_leaky_relu(::second::protos::LeakyReLU* leaky_relu);

  // .second.protos.Swish swish = 3;
  bool has_swish() const;
  void clear_swish();
  const ::second::protos::Swish& swish() const;
  ::second::protos::Swish* release_swish();
  ::second::protos::Swish* mutable_swish();
  void set_allocated_swish(::second::protos::Swish* swish);

  // .second.protos.ELU elu = 4;
  bool has_elu() const;
  void clear_elu();
  const ::second::protos::ELU& elu() const;
  ::second::protos::ELU* release_elu();
  ::second::protos::ELU* mutable_elu();
  void set_allocated_elu(::second::protos::ELU* elu);

  // .second.protos.Softplus softplus = 5;
  bool has_softplus() const;
  void clear_softplus();
  const ::second::protos::Softplus& softplus() const;
  ::second::protos::Softplus* release_softplus();
  ::second::protos::Softplus* mutable_softplus();
  void set_allocated_softplus(::second::protos::Softplus* softplus);

  // .second.protos.Softsign softsign = 6;
  bool has_softsign() const;
  void clear_softsign();
  const ::second::protos::Softsign& softsign() const;
  ::second::protos::Softsign* release_softsign();
  ::second::protos::Softsign* mutable_softsign();
  void set_allocated_softsign(::second::protos::Softsign* softsign);

  // .second.protos.ReLU6 relu6 = 7;
  bool has_relu6() const;
  void clear_relu6();
  const ::second::protos::ReLU6& relu6() const;
  ::second::protos::ReLU6* release_relu6();
  ::second::protos::ReLU6* mutable_relu6();
  void set_allocated_relu6(::second::protos::ReLU6* relu6);

  // .second.protos.SELU selu = 8;
  bool has_selu() const;
  void clear_selu();
  const ::second::protos::SELU& selu() const;
  ::second::protos::SELU* release_selu();
  ::second::protos::SELU* mutable_selu();
  void set_allocated_selu(::second::protos::SELU* selu);

  void clear_activation();
  ActivationCase activation_case() const;
  // @@protoc_insertion_point(class_scope:second.protos.Activation)
 private:
  class _Internal;
  void set_has_relu();
  void set_has_leaky_relu();
  void set_has_swish();
  void set_has_elu();
  void set_has_softplus();
  void set_has_softsign();
  void set_has_relu6();
  void set_has_selu();

  inline bool has_activation() const;
  inline void clear_has_activation();

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  union ActivationUnion {
    ActivationUnion() {}
    ::second::protos::ReLU* relu_;
    ::second::protos::LeakyReLU* leaky_relu_;
    ::second::protos::Swish* swish_;
    ::second::protos::ELU* elu_;
    ::second::protos::Softplus* softplus_;
    ::second::protos::Softsign* softsign_;
    ::second::protos::ReLU6* relu6_;
    ::second::protos::SELU* selu_;
  } activation_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_second_2fprotos_2factivations_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// ReLU

// -------------------------------------------------------------------

// LeakyReLU

// float leakness = 1;
inline void LeakyReLU::clear_leakness() {
  leakness_ = 0;
}
inline float LeakyReLU::leakness() const {
  // @@protoc_insertion_point(field_get:second.protos.LeakyReLU.leakness)
  return leakness_;
}
inline void LeakyReLU::set_leakness(float value) {
  
  leakness_ = value;
  // @@protoc_insertion_point(field_set:second.protos.LeakyReLU.leakness)
}

// -------------------------------------------------------------------

// Swish

// -------------------------------------------------------------------

// ELU

// float alpha = 1;
inline void ELU::clear_alpha() {
  alpha_ = 0;
}
inline float ELU::alpha() const {
  // @@protoc_insertion_point(field_get:second.protos.ELU.alpha)
  return alpha_;
}
inline void ELU::set_alpha(float value) {
  
  alpha_ = value;
  // @@protoc_insertion_point(field_set:second.protos.ELU.alpha)
}

// -------------------------------------------------------------------

// Softplus

// float beta = 1;
inline void Softplus::clear_beta() {
  beta_ = 0;
}
inline float Softplus::beta() const {
  // @@protoc_insertion_point(field_get:second.protos.Softplus.beta)
  return beta_;
}
inline void Softplus::set_beta(float value) {
  
  beta_ = value;
  // @@protoc_insertion_point(field_set:second.protos.Softplus.beta)
}

// float threshold = 2;
inline void Softplus::clear_threshold() {
  threshold_ = 0;
}
inline float Softplus::threshold() const {
  // @@protoc_insertion_point(field_get:second.protos.Softplus.threshold)
  return threshold_;
}
inline void Softplus::set_threshold(float value) {
  
  threshold_ = value;
  // @@protoc_insertion_point(field_set:second.protos.Softplus.threshold)
}

// -------------------------------------------------------------------

// Softsign

// -------------------------------------------------------------------

// ReLU6

// -------------------------------------------------------------------

// SELU

// -------------------------------------------------------------------

// Activation

// .second.protos.ReLU relu = 1;
inline bool Activation::has_relu() const {
  return activation_case() == kRelu;
}
inline void Activation::set_has_relu() {
  _oneof_case_[0] = kRelu;
}
inline void Activation::clear_relu() {
  if (has_relu()) {
    delete activation_.relu_;
    clear_has_activation();
  }
}
inline ::second::protos::ReLU* Activation::release_relu() {
  // @@protoc_insertion_point(field_release:second.protos.Activation.relu)
  if (has_relu()) {
    clear_has_activation();
      ::second::protos::ReLU* temp = activation_.relu_;
    activation_.relu_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::second::protos::ReLU& Activation::relu() const {
  // @@protoc_insertion_point(field_get:second.protos.Activation.relu)
  return has_relu()
      ? *activation_.relu_
      : *reinterpret_cast< ::second::protos::ReLU*>(&::second::protos::_ReLU_default_instance_);
}
inline ::second::protos::ReLU* Activation::mutable_relu() {
  if (!has_relu()) {
    clear_activation();
    set_has_relu();
    activation_.relu_ = CreateMaybeMessage< ::second::protos::ReLU >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:second.protos.Activation.relu)
  return activation_.relu_;
}

// .second.protos.LeakyReLU leaky_relu = 2;
inline bool Activation::has_leaky_relu() const {
  return activation_case() == kLeakyRelu;
}
inline void Activation::set_has_leaky_relu() {
  _oneof_case_[0] = kLeakyRelu;
}
inline void Activation::clear_leaky_relu() {
  if (has_leaky_relu()) {
    delete activation_.leaky_relu_;
    clear_has_activation();
  }
}
inline ::second::protos::LeakyReLU* Activation::release_leaky_relu() {
  // @@protoc_insertion_point(field_release:second.protos.Activation.leaky_relu)
  if (has_leaky_relu()) {
    clear_has_activation();
      ::second::protos::LeakyReLU* temp = activation_.leaky_relu_;
    activation_.leaky_relu_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::second::protos::LeakyReLU& Activation::leaky_relu() const {
  // @@protoc_insertion_point(field_get:second.protos.Activation.leaky_relu)
  return has_leaky_relu()
      ? *activation_.leaky_relu_
      : *reinterpret_cast< ::second::protos::LeakyReLU*>(&::second::protos::_LeakyReLU_default_instance_);
}
inline ::second::protos::LeakyReLU* Activation::mutable_leaky_relu() {
  if (!has_leaky_relu()) {
    clear_activation();
    set_has_leaky_relu();
    activation_.leaky_relu_ = CreateMaybeMessage< ::second::protos::LeakyReLU >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:second.protos.Activation.leaky_relu)
  return activation_.leaky_relu_;
}

// .second.protos.Swish swish = 3;
inline bool Activation::has_swish() const {
  return activation_case() == kSwish;
}
inline void Activation::set_has_swish() {
  _oneof_case_[0] = kSwish;
}
inline void Activation::clear_swish() {
  if (has_swish()) {
    delete activation_.swish_;
    clear_has_activation();
  }
}
inline ::second::protos::Swish* Activation::release_swish() {
  // @@protoc_insertion_point(field_release:second.protos.Activation.swish)
  if (has_swish()) {
    clear_has_activation();
      ::second::protos::Swish* temp = activation_.swish_;
    activation_.swish_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::second::protos::Swish& Activation::swish() const {
  // @@protoc_insertion_point(field_get:second.protos.Activation.swish)
  return has_swish()
      ? *activation_.swish_
      : *reinterpret_cast< ::second::protos::Swish*>(&::second::protos::_Swish_default_instance_);
}
inline ::second::protos::Swish* Activation::mutable_swish() {
  if (!has_swish()) {
    clear_activation();
    set_has_swish();
    activation_.swish_ = CreateMaybeMessage< ::second::protos::Swish >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:second.protos.Activation.swish)
  return activation_.swish_;
}

// .second.protos.ELU elu = 4;
inline bool Activation::has_elu() const {
  return activation_case() == kElu;
}
inline void Activation::set_has_elu() {
  _oneof_case_[0] = kElu;
}
inline void Activation::clear_elu() {
  if (has_elu()) {
    delete activation_.elu_;
    clear_has_activation();
  }
}
inline ::second::protos::ELU* Activation::release_elu() {
  // @@protoc_insertion_point(field_release:second.protos.Activation.elu)
  if (has_elu()) {
    clear_has_activation();
      ::second::protos::ELU* temp = activation_.elu_;
    activation_.elu_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::second::protos::ELU& Activation::elu() const {
  // @@protoc_insertion_point(field_get:second.protos.Activation.elu)
  return has_elu()
      ? *activation_.elu_
      : *reinterpret_cast< ::second::protos::ELU*>(&::second::protos::_ELU_default_instance_);
}
inline ::second::protos::ELU* Activation::mutable_elu() {
  if (!has_elu()) {
    clear_activation();
    set_has_elu();
    activation_.elu_ = CreateMaybeMessage< ::second::protos::ELU >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:second.protos.Activation.elu)
  return activation_.elu_;
}

// .second.protos.Softplus softplus = 5;
inline bool Activation::has_softplus() const {
  return activation_case() == kSoftplus;
}
inline void Activation::set_has_softplus() {
  _oneof_case_[0] = kSoftplus;
}
inline void Activation::clear_softplus() {
  if (has_softplus()) {
    delete activation_.softplus_;
    clear_has_activation();
  }
}
inline ::second::protos::Softplus* Activation::release_softplus() {
  // @@protoc_insertion_point(field_release:second.protos.Activation.softplus)
  if (has_softplus()) {
    clear_has_activation();
      ::second::protos::Softplus* temp = activation_.softplus_;
    activation_.softplus_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::second::protos::Softplus& Activation::softplus() const {
  // @@protoc_insertion_point(field_get:second.protos.Activation.softplus)
  return has_softplus()
      ? *activation_.softplus_
      : *reinterpret_cast< ::second::protos::Softplus*>(&::second::protos::_Softplus_default_instance_);
}
inline ::second::protos::Softplus* Activation::mutable_softplus() {
  if (!has_softplus()) {
    clear_activation();
    set_has_softplus();
    activation_.softplus_ = CreateMaybeMessage< ::second::protos::Softplus >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:second.protos.Activation.softplus)
  return activation_.softplus_;
}

// .second.protos.Softsign softsign = 6;
inline bool Activation::has_softsign() const {
  return activation_case() == kSoftsign;
}
inline void Activation::set_has_softsign() {
  _oneof_case_[0] = kSoftsign;
}
inline void Activation::clear_softsign() {
  if (has_softsign()) {
    delete activation_.softsign_;
    clear_has_activation();
  }
}
inline ::second::protos::Softsign* Activation::release_softsign() {
  // @@protoc_insertion_point(field_release:second.protos.Activation.softsign)
  if (has_softsign()) {
    clear_has_activation();
      ::second::protos::Softsign* temp = activation_.softsign_;
    activation_.softsign_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::second::protos::Softsign& Activation::softsign() const {
  // @@protoc_insertion_point(field_get:second.protos.Activation.softsign)
  return has_softsign()
      ? *activation_.softsign_
      : *reinterpret_cast< ::second::protos::Softsign*>(&::second::protos::_Softsign_default_instance_);
}
inline ::second::protos::Softsign* Activation::mutable_softsign() {
  if (!has_softsign()) {
    clear_activation();
    set_has_softsign();
    activation_.softsign_ = CreateMaybeMessage< ::second::protos::Softsign >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:second.protos.Activation.softsign)
  return activation_.softsign_;
}

// .second.protos.ReLU6 relu6 = 7;
inline bool Activation::has_relu6() const {
  return activation_case() == kRelu6;
}
inline void Activation::set_has_relu6() {
  _oneof_case_[0] = kRelu6;
}
inline void Activation::clear_relu6() {
  if (has_relu6()) {
    delete activation_.relu6_;
    clear_has_activation();
  }
}
inline ::second::protos::ReLU6* Activation::release_relu6() {
  // @@protoc_insertion_point(field_release:second.protos.Activation.relu6)
  if (has_relu6()) {
    clear_has_activation();
      ::second::protos::ReLU6* temp = activation_.relu6_;
    activation_.relu6_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::second::protos::ReLU6& Activation::relu6() const {
  // @@protoc_insertion_point(field_get:second.protos.Activation.relu6)
  return has_relu6()
      ? *activation_.relu6_
      : *reinterpret_cast< ::second::protos::ReLU6*>(&::second::protos::_ReLU6_default_instance_);
}
inline ::second::protos::ReLU6* Activation::mutable_relu6() {
  if (!has_relu6()) {
    clear_activation();
    set_has_relu6();
    activation_.relu6_ = CreateMaybeMessage< ::second::protos::ReLU6 >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:second.protos.Activation.relu6)
  return activation_.relu6_;
}

// .second.protos.SELU selu = 8;
inline bool Activation::has_selu() const {
  return activation_case() == kSelu;
}
inline void Activation::set_has_selu() {
  _oneof_case_[0] = kSelu;
}
inline void Activation::clear_selu() {
  if (has_selu()) {
    delete activation_.selu_;
    clear_has_activation();
  }
}
inline ::second::protos::SELU* Activation::release_selu() {
  // @@protoc_insertion_point(field_release:second.protos.Activation.selu)
  if (has_selu()) {
    clear_has_activation();
      ::second::protos::SELU* temp = activation_.selu_;
    activation_.selu_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::second::protos::SELU& Activation::selu() const {
  // @@protoc_insertion_point(field_get:second.protos.Activation.selu)
  return has_selu()
      ? *activation_.selu_
      : *reinterpret_cast< ::second::protos::SELU*>(&::second::protos::_SELU_default_instance_);
}
inline ::second::protos::SELU* Activation::mutable_selu() {
  if (!has_selu()) {
    clear_activation();
    set_has_selu();
    activation_.selu_ = CreateMaybeMessage< ::second::protos::SELU >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:second.protos.Activation.selu)
  return activation_.selu_;
}

inline bool Activation::has_activation() const {
  return activation_case() != ACTIVATION_NOT_SET;
}
inline void Activation::clear_has_activation() {
  _oneof_case_[0] = ACTIVATION_NOT_SET;
}
inline Activation::ActivationCase Activation::activation_case() const {
  return Activation::ActivationCase(_oneof_case_[0]);
}
#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace protos
}  // namespace second

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_second_2fprotos_2factivations_2eproto
